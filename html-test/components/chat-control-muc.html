<template>
    <!-- Note: At this point, the character/dialogue class and cursor pointer are hardcoded in 
       - chat component, while additional classes are derived from fromNickname -->
    <p id="muc-character" class="character"></p>
    <p id="muc-dialogue" class="dialogue" style="cursor:pointer"></p>
</template>

<script>
    // TODO: This seems to only work in Chrome, verifying.
    
    // chat-control-muc: Chat control component for observatory is an XMPP client
    //   that connects to a chatroom on a given XMPP host, and talks to it
    //   
    // @dependency: Strophe.js, Strophe.muc.js, jquery
    //
    // @env connection XMPP connection should be established to use this component
    // @env chatroom connection This user should join the chatroom in order to send messages to that chatroom
    //
    // @param roomJID The chatroom JID on the XMPP host; 
    //    if not specified, the component will look for if defaultMucRoom is defined
    // @param message The message to be sent
    // @param fromNickname This user's nickname in the muc chatroom;
    //    this name is also used for css class and the name of the dialogue character
    //    if not specified, the component will look for if defaultMucNickName is defined
    
    (function(window, document, undefined) {
        var thatDoc = document;
        var thisDoc =  (thatDoc._currentScript || thatDoc.currentScript).ownerDocument;
        var template = thisDoc.querySelector('template').content;
        
        var ChatControlMucElement = Object.create(HTMLElement.prototype);
        
        ChatControlMucElement.createdCallback = function() {
            var shadowRoot = this.createShadowRoot();
            var clone = thatDoc.importNode(template, true);
            shadowRoot.appendChild(clone);
            
            // We may not want to contain these in a paragraph at some point
            this.characterElement = shadowRoot.querySelector('#muc-character');
            this.dialogueElement = shadowRoot.querySelector('#muc-dialogue');
            
            if (this.hasAttribute('style')) {
                var style = this.getAttribute('style');
                this.characterElement.setAttribute("style", style);
            }
            else {
                
            }
            
            this.roomJID = '';
            if (this.hasAttribute('roomJID')) {
                this.roomJID = this.getAttribute('roomJID');
            } else {
                if (window.defaultMucRoom == undefined || window.defaultMucRoom == null || window.defaultMucRoom == '') {
                    console.log('Room JID not specified; defaultMucRoom definition not found, either');
                    return;
                } else {
                    this.roomJID = window.defaultMucRoom;
                }
            }
            
            this.fromNickname = ''
            if (this.hasAttribute('fromNickname')) {
                fromNickname = this.getAttribute('fromNickname');
            } else {
                if (window.defaultMucNickName == undefined || window.defaultMucNickName == null || window.defaultMucNickName == '') {
                    console.log('Default nickname not specified; defaultMucNickName definition not found, either');
                    return;
                } else {
                    this.fromNickname = window.defaultMucNickName;
                }
            }
            
            this.content = '';
            
            if (this.hasAttribute('message')) {
                this.content = this.getAttribute('message');
            } else {
                console.log('Message content should not be empty');
                return;
            }
            
            // Use "inherited" style sheet
            // Note: This may not be ideal for applying the CSS styles from window's document
            var characterStyle = this.getStyle(window.document, ".character");
            if (characterStyle != undefined) {
                this.copyStyleToElement(characterStyle.style, this.characterElement);
            }
            
            var dialogueStyle = this.getStyle(window.document, ".dialogue");
            if (dialogueStyle != undefined) {
                this.copyStyleToElement(dialogueStyle.style, this.dialogueElement);
            }
            
            var specificStyle = this.getStyle(window.document, "." + this.htmlClassFromName(this.fromNickname));
            var specificDialogueStyle = this.getStyle(window.document, "." + this.htmlClassFromName(this.fromNickname) + "-dialogue");
            if (specificStyle != undefined) {
                this.copyStyleToElement(specificStyle.style, this.characterElement);
            }
            if (specificDialogueStyle != undefined) {
                this.copyStyleToElement(specificDialogueStyle.style, this.dialogueElement);
            }
            
            // Override cursor style for dialogue
            this.dialogueElement.style["cursor"] = "pointer";
            
            // Apply text for elements
            this.characterElement.setAttribute("class", this.characterElement.getAttribute("class") + " " + this.htmlClassFromName(this.fromNickname));
            this.dialogueElement.setAttribute("class", this.dialogueElement.getAttribute("class") + " " + this.htmlClassFromName(this.fromNickname) + "-dialogue");
            
            this.characterElement.textContent = this.fromNickname.toUpperCase();
            this.dialogueElement.textContent = this.content;
            
            var self = this;
            
            this.dialogueElement.addEventListener('click', function(){
                console.log('chatControlMuc click called');
                if (connection == undefined || connection == null) {
                    console.log('XMPP connection not established');
                    return;
                }
                
                var message = $msg({
                  "to" : self.roomJID,
                  "type" : 'groupchat',
                  "from_nickname" : self.fromNickname,
                }).c("body").t(self.content);
                
                connection.send(message.tree());
            });
        };
        ChatControlMucElement.attributeChangedCallback = function(attr, oldVal, newVal) {
            console.log('chatControlMuc onAttributeChanged stub');
        };
        ChatControlMucElement.htmlClassFromName = function(fromName) {
            str = fromName.toLowerCase().replace(' ', '-');
            return str;
        };
        ChatControlMucElement.getStyle = function(document, className) {
            var classes = document.styleSheets[0].rules || document.styleSheets[0].cssRules;
            for (var i = 0; i < classes.length; i++) {
                if (classes[i].selectorText == className) {
                    return classes[i];
                }
            }
        };
        ChatControlMucElement.copyStyleToElement = function(cs, to) {
            for (var prop in cs) {
                if (cs[prop] != undefined && cs[prop].length > 0 && 
                    typeof cs[prop] !== 'object' && typeof cs[prop] !== 'function' && 
                    prop != parseInt(prop) ) {
                    
                    to.style[prop] = cs[prop];
                }
            }
        };
        window.chatControlMucElement = thatDoc.registerElement('com-chat-control-muc', {
            prototype: ChatControlMucElement
        });
    })(window, document);
</script>